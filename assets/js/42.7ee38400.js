(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{338:function(a,t,r){"use strict";r.r(t);var e=r(10),s=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"小程序的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小程序的生命周期"}},[a._v("#")]),a._v(" 小程序的生命周期")]),a._v(" "),t("p",[a._v("小程序的生命周期分为: 应用的生命周期、页面的生命周期、组件的生命周期")]),a._v(" "),t("h2",{attrs:{id:"应用的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用的生命周期"}},[a._v("#")]),a._v(" 应用的生命周期")]),a._v(" "),t("h5",{attrs:{id:"onlaunch事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#onlaunch事件"}},[a._v("#")]),a._v(" onLaunch事件")]),a._v(" "),t("p",[a._v("在小程序代码包被注入宿主环境,初始化完毕后触发")]),a._v(" "),t("h5",{attrs:{id:"onhide事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#onhide事件"}},[a._v("#")]),a._v(" onHide事件")]),a._v(" "),t("p",[a._v("在点击返回或Home健时,此时小程序进入后台,并没有被关闭,此时触发")]),a._v(" "),t("h5",{attrs:{id:"onshow事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#onshow事件"}},[a._v("#")]),a._v(" onShow事件")]),a._v(" "),t("p",[a._v("在再次回到小程序,即后代的小程序从后台被唤醒时触发")]),a._v(" "),t("h5",{attrs:{id:"onerror事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#onerror事件"}},[a._v("#")]),a._v(" onError事件")]),a._v(" "),t("p",[a._v("在代码运行出错时触发该事件")]),a._v(" "),t("blockquote",[t("p",[a._v("注意:")]),a._v(" "),t("p",[a._v("1.我们可以看到，App的生命周期是由微信客户端根据用户操作主动触发的。为了避免程序上的混乱，我们不应该从其他代码里主动调用App实例的生命周期函数。")]),a._v(" "),t("p",[a._v("2.在微信客户端中打开小程序有很多途径：从群聊会话里打开，从小程序列表中打开，通过微信扫一扫二维码打开，从另外一个小程序打开当前小程序等，针对不同途径的打开方式，小程序有时需要做不同的业务处理，所以微信客户端会把打开方式带给onLaunch和onShow的调用参数options")]),a._v(" "),t("p",[a._v("3.onLaunch, onShow 方法会返回一个参数对象， 里面包含了三个参数 ， path,query和scene ，path是打开小程序的路径,query是打开小程序页面url的参数，scene是打开小程序的场景值")])]),a._v(" "),t("h2",{attrs:{id:"页面的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#页面的生命周期"}},[a._v("#")]),a._v(" 页面的生命周期")]),a._v(" "),t("h5",{attrs:{id:"onload事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#onload事件"}},[a._v("#")]),a._v(" onLoad事件")]),a._v(" "),t("p",[a._v("页面初次加载的时候,Page构造器参数所定义的onLoad方法会被调用")]),a._v(" "),t("h5",{attrs:{id:"onready事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#onready事件"}},[a._v("#")]),a._v(" onReady事件")]),a._v(" "),t("p",[a._v("页面初次渲染之后触发")]),a._v(" "),t("h5",{attrs:{id:"onhide事件-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#onhide事件-2"}},[a._v("#")]),a._v(" onHide事件")]),a._v(" "),t("p",[a._v("离开当前页面时触发")]),a._v(" "),t("h5",{attrs:{id:"onunload事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#onunload事件"}},[a._v("#")]),a._v(" onUnload事件")]),a._v(" "),t("p",[a._v("当前页面从页面栈中被销毁时触发")]),a._v(" "),t("blockquote",[t("p",[a._v("注意:")]),a._v(" "),t("p",[a._v("1.onLoad在页面没被销毁之前只会触发1次，在onLoad的回调中，可以获取当前页面所调用的打开参数option。\n页面显示之后，Page构造器参数所定义的onShow方法会被调用，一般从别的页面返回到当前页面时，当前页的onShow方法都会被调用。")])]),a._v(" "),t("h2",{attrs:{id:"组件的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件的生命周期"}},[a._v("#")]),a._v(" 组件的生命周期")]),a._v(" "),t("h5",{attrs:{id:"created事件-与vue不同-此处不能进行数据操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#created事件-与vue不同-此处不能进行数据操作"}},[a._v("#")]),a._v(" created事件(与vue不同,此处不能进行数据操作)")]),a._v(" "),t("p",[a._v("在组件实例刚刚被创建时执行")]),a._v(" "),t("h5",{attrs:{id:"attached事件-此处可以进行数据操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#attached事件-此处可以进行数据操作"}},[a._v("#")]),a._v(" attached事件(此处可以进行数据操作)")]),a._v(" "),t("p",[a._v("在组件实例进入页面节点树时执行")]),a._v(" "),t("h5",{attrs:{id:"ready事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ready事件"}},[a._v("#")]),a._v(" ready事件")]),a._v(" "),t("p",[a._v("在组件在视图层布局完成后执行")]),a._v(" "),t("h5",{attrs:{id:"moved事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#moved事件"}},[a._v("#")]),a._v(" moved事件")]),a._v(" "),t("p",[a._v("在组件实例被移动到节点树另一个位置时执行")]),a._v(" "),t("h5",{attrs:{id:"detached事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#detached事件"}},[a._v("#")]),a._v(" detached事件")]),a._v(" "),t("p",[a._v("在组件实例被从页面节点树移除时执行")]),a._v(" "),t("h5",{attrs:{id:"error事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#error事件"}},[a._v("#")]),a._v(" error事件")]),a._v(" "),t("p",[a._v("每当组件方法抛出错误时执行")]),a._v(" "),t("h4",{attrs:{id:"组件所在页面的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件所在页面的生命周期"}},[a._v("#")]),a._v(" 组件所在页面的生命周期")]),a._v(" "),t("h5",{attrs:{id:"show事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#show事件"}},[a._v("#")]),a._v(" show事件")]),a._v(" "),t("p",[a._v("组件所在的页面被展示时执行")]),a._v(" "),t("h5",{attrs:{id:"hide事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hide事件"}},[a._v("#")]),a._v(" hide事件")]),a._v(" "),t("p",[a._v("组件所在的页面被隐藏时执行")]),a._v(" "),t("h5",{attrs:{id:"resize事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#resize事件"}},[a._v("#")]),a._v(" resize事件")]),a._v(" "),t("p",[a._v("组件所在的页面尺寸变化时执行")]),a._v(" "),t("blockquote",[t("p",[a._v("注意:")]),a._v(" "),t("p",[a._v("在 behaviors 中也可以编写生命周期方法(建议使用此方法)，同时不会与其他 behaviors 中的同名生命周期相互覆盖。但要注意，如果一个组件多次直接或间接引用同一个 behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次。")])])])}),[],!1,null,null,null);t.default=s.exports}}]);